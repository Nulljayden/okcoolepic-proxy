const _typeof = (() => {
  'use strict';

  if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
    };
  }

  return _typeof;
})();

const _classCallCheck = (() => {
  'use strict';

  return function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  };
})();

const _possibleConstructorReturn = (() => {
  'use strict';

  return function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === 'object' || typeof call === 'function')) {
      return call;
    }

    if (!self) {
      throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called');
    }

    return self;
  };
})();

const _inherits = (() => {
  'use strict';

  if (typeof Super !== 'function' && Super !== null) {
    throw new TypeError('Super expression must either be null or a function');
  }

  return function _inherits(subClass, superClass) {
    if (typeof superClass !== 'function' && superClass !== null) {
      throw new TypeError('Super expression must either be null or a function');
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });

    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };
})();

import { decode } from "@webassemblyjs/wasm-parser";
import { shrinkPaddedLEB128 as makeShrinkPaddedLEB128 } from "./leb128.js";

class OptimizerError extends Error {
  constructor(name, initalError) {
    super(`Error while optimizing: ${name}: ${initalError.message}`);
    this.stack = initalError.stack;
    this.name = name;
  }
}

const decoderOpts = {
  ignoreCodeSection: true,
  ignoreDataSection: true
};

const shrinkPaddedLEB128 = (uint8Buffer) => {
  try {
    const ast = decode(uint8Buffer.buffer, decoderOpts);
    return makeShrinkPaddedLEB128(ast, uint8Buffer);
  } catch
