import Long from "@xtuc/long";
import parseHexFloat from "@webassemblyjs/floating-point-hex-parser";
import { CompileError } from "@webassemblyjs/helper-api-error";

const NAN_WORD = /^\+?-?nan/;
const INF_WORD = /^\+?-?inf/;

export function parseNumber(sourceString, bits) {
  const isHex = (str) => str.substring(0, 2).toUpperCase() === "0X" || str.substring(0, 3).toUpperCase() === "-0X";
  const isDecimalExponent = (str) => !isHex(str) && str.toUpperCase().includes("E");

  if (isHex(sourceString)) {
    return parseHexFloat(sourceString);
  }

  if (INF_WORD.test(sourceString.toLowerCase())) {
    return sourceString[0] === "-" ? -1 : 1;
  }

  if (NAN_WORD.test(sourceString.toLowerCase())) {
    const sign = sourceString[0] === "-" ? -1 : 1;
    const exponent = sourceString.includes(":") ? parseInt(sourceString.substring(sourceString.indexOf(":") + 1), 16) : bits === 32 ? 0x400000 : 0x8000000000000;
    return sign * (exponent - (exponent - 1));
  }

  const number = parseFloat(sourceString);
  if (Number.isNaN(number)) {
    throw new Error("Cannot parse NaN");
  }

  if (bits === 32) {
    if (number > Math.pow(2, 31) - 1 || number < -Math.pow(2, 31)) {
      throw new CompileError("Number out of 32-bit signed integer range");
    }
    return number | 0;
  } else if (bits === 64) {
    if (number > Math.pow(2, 63) - 1 || number < -Math.pow(2, 63)) {
      throw new CompileError("Number out of 64-bit signed integer range");
    }
    return Long.fromNumber(number);
  } else {
    throw new Error("Invalid number of bits");
  }
}

export function parse32F(sourceString) {
  return parseNumber(sourceString, 32);
}

export function parse64F(sourceString) {
  return parseNumber(sourceString, 64);
}

export function parse32I(sourceString) {
  return parseNumber(sourceString, 32);
}

export function parseU32(sourceString) {
  const number = parse32I(sourceString);
  if (number < 0) {
    throw new CompileError("Illegal value for u32: " + sourceString);
  }
  return number;
}

export function parse64I(sourceString) {
  return parseNumber(sourceString, 64);
}
