"use strict";

import {
  encodeModuleImport,
  encodeSectionMetadata,
  encodeCallInstruction,
  encodeCallIndirectInstruction,
  encodeTypeInstruction,
  encodeInstr,
  encodeModuleExport,
  encodeGlobal,
  encodeFuncBody,
  encodeIndexInFuncSection,
  encodeStringLiteral,
  encodeElem
} from "./encoder";

Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeNode = encodeNode;
exports.encodeU32 = encodeU32;

function encodeNode(n: { type: string }): Uint8Array {
  if (n === null || n === undefined) {
    throw new Error("Node cannot be null or undefined");
  }

  switch (n.type) {
    case "ModuleImport":
      return encodeModuleImport(n);

    case "SectionMetadata":
      return encodeSectionMetadata(n);

    case "CallInstruction":
      return encodeCallInstruction(n);

    case "CallIndirectInstruction":
      return encodeCallIndirectInstruction(n);

    case "TypeInstruction":
      return encodeTypeInstruction(n);

    case "Instr":
      return encodeInstr(n);

    case "ModuleExport":
      return encodeModuleExport(n);

    case "Global":
      return encodeGlobal(n);

    case "Func":
      return encodeFuncBody(n);

    case "IndexInFuncSection":
      return encodeIndexInFuncSection(n);

    case "StringLiteral":
      return encodeStringLiteral(n);

    case "Elem":
      return encodeElem(n);

    default:
      throw new Error("Unsupported encoding for node of type: " + n.type);
  }
}

const { encodeU32 } = encoder;
exports.encodeU32 = encodeU32;
