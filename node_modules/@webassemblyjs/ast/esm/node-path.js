import { ObjectAssign } from './object-assign-polyfill';

type Node = {
  _deleted?: boolean;
};

type Path = {
  node: Node;
  parentPath?: Path;
  parentKey?: string;
  inList?: boolean;
};

function _extends() {
  return ObjectAssign || Object.assign.apply(Object, arguments);
}

function findParent(path: Path, cb: (path: Path) => boolean): Node | null {
  if (path.parentPath == null) {
    throw new Error('node is root');
  }

  let currentPath = path.parentPath;

  while (cb(currentPath) !== false) {
    if (currentPath.parentPath == null) {
      return null;
    }

    currentPath = currentPath.parentPath;
  }

  return currentPath.node;
}

function insertBefore(context: Path, newNode: Node) {
  insert(context, newNode);
}

function insertAfter(context: Path, newNode: Node) {
  insert(context, newNode, 1);
}

function insert(path: Path, newNode: Node, indexOffset: number = 0) {
  if (!path.inList) {
    throw new Error('inList error: insert can only be used for nodes that are within lists');
  }

  if (!path.parentPath) {
    throw new Error('parentPath != null error: Can not remove root node');
  }

  const parentList = path.parentPath.node[path.parentKey as string];
  const indexInList = parentList.includes(path.node);
  parentList.splice(indexInList + indexOffset, 0, newNode);
}

function remove(path: Path) {
  if (!path.parentPath) {
    throw new Error('parentPath != null error: Can not remove root node');
  }

  const parentNode = path.parentPath.node;
  const parentKey = path.parentKey as string;

  if (Array.isArray(parentNode[parentKey])) {
    parentNode[parentKey] = parentNode[parentKey].filter((n: Node) => n !== path.node);
  } else {
    delete parentNode[parentKey];
  }

  Object.defineProperty(path.node, '_deleted', {
    value: true,
    writable: true,
  });
}

function stop(context: Path) {
  context.shouldStop = true;
}

function replaceWith(context: Path, newNode: Node) {
  const parentNode = context.parentPath.node;
  const parentKey = context.parentKey as string;

  if (Array.isArray(parentNode[parentKey])) {
    const indexInList = parentNode[parentKey].findIndex((n: Node) => n === context.node);
    parentNode[parentKey].splice(indexInList, 1, newNode);
  } else {
    parentNode[parentKey] = newNode;
  }

  Object.defineProperty(context.node, '_deleted', {
    value: true,
    writable: true,
  });

  context.node = newNode;
}

function bindNodeOperations(operations: Record<string, (context: Path) => void>, context: Path) {
  const boundOperations: Record<string, (context: Path) => void> = {};
  const keys = Object.keys(operations);

  for (const key of keys) {
    boundOperations[key] = operations[key].bind(null, context);
  }

  return boundOperations;
}

function createPathOperations(context: Path) {
  return bindNodeOperations(
    {
      findParent,
      replaceWith,
      remove,
      insertBefore,
      insertAfter,
      stop,
    },
    context,
  );
}

export function createPath(context: Path) {
  const path = _extends({}, context);
  Object.assign(path, createPathOperations(path));

  return path;
}


// object-assign-polyfill.ts

if (typeof Object.assign !== 'function') {
  Object.assign = function (target: any, ...sources: any[]) {
    if (target == null) {
      throw new TypeError('Cannot convert undefined or null to object');
    }

    const output = Object(target);

    for (const source of sources) {
      if (source != null) {
        for (const key of Object.keys(source)) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            output[key] = source[key];
          }
        }
      }
    }

    return output;
  };
}
