"use strict";

import { traverse } from "../../index";
import {
  moduleContextFromModuleAST,
  isIdentifier,
  numberLiteralFromRaw
} from "../ast-module-to-module-context";

// Returns an error for an unknown function at the given offset
function newUnexpectedFunction(offset: number): Error {
  return new Error(`unknown function at offset: ${offset}`);
}

// Transforms the given abstract syntax tree (AST) by replacing identifier nodes
// with number literal nodes for function offsets, global offsets, and labels.
function transform(ast: any) {
  let module: any;
  traverse(ast, {
    Module: function (path) {
      function Module(_path: any) {
        return _path.apply(this, arguments);
      }

      Module.toString = function () {
        return _path.toString();
      };

      return Module;
    }(function (path) {
      module = path.node;
    })
  });
  const moduleContext = moduleContextFromModuleAST(module); // Transform the actual instruction in function bodies

  traverse(ast, {
    Func: function (_Func: any) {
      function Func(_path: any) {
        return _Func.apply(this, arguments);
      }

      Func.toString = function () {
        return _Func.toString();
      };

      return Func;
    }(function (path) {
      transformFuncPath(path, moduleContext);
    }),
    Start: function (_Start: any) {
      function Start(_path: any) {
        return _Start.apply(this, arguments);
      }

      Start.toString = function () {
        return _Start.toString();
      };

      return Start;
    }(function (path) {
      const index = path.node.index;

      if (isIdentifier(index)) {
        const offsetInModule = moduleContext.getFunctionOffsetByIdentifier(index.value);

        if (typeof offsetInModule === "undefined") {
          throw newUnexpectedFunction(index.value);
        } // Replace the index Identifier
        // $FlowIgnore: reference?

        path.node.index = numberLiteralFromRaw(offsetInModule);
      }
    })
  });
}

// Transforms the given function path by replacing identifier nodes with number
// literal nodes for function locals, globals, and labels.
function transformFuncPath(funcPath: any, moduleContext: any) {
  const funcNode = funcPath.node;
  const signature = funcNode.signature;

  if (signature.type !== "Signature") {
    throw new Error(
      "Function signatures must be denormalised before execution"
    );
  }

  const params = signature.params; // Add func locals in the context

  params.forEach(function (p: any) {
    return moduleContext.addLocal(p.valtype);
  });
  traverse(funcNode, {
    Instr: function (_Instr: any) {
      function Instr(_path: any) {
        return _Instr.apply(this, arguments);
      }

      Instr.toString = function () {
        return _Instr.toString();
      };

      return Instr;
    }(function (instrPath: any) {
      const instrNode = instrPath.node;
      /**
       * Local access
       */

      if (instrNode.id === "get_local" || instrNode.id === "set_local" || instrNode.id === "tee_local") {
        const _instrNode$args = _slicedToArray(instrNode.args, 1),
          firstArg = _instrNode$args[0];

        if (isIdentifier(firstArg)) {
          const offsetInParams = params.findIndex(function (_ref: any) {
            const id = _ref.id;
            return id === firstArg.value;
          });

          if (offsetInParams === -1) {
            throw new Error(
              `${firstArg.value} not found in ${instrNode.id}: not declared in func params`
            );
          } // Replace the Identifer node by our new NumberLiteral node

          instrNode.args[0] = numberLiteralFromRaw(offsetInParams);
        }
      }
      /**
       * Global access
       */

      if (instrNode.id === "get_global" || instrNode.id === "set_global") {
        const _instrNode$args2 = _slicedToArray(instrNode.args, 1),
          _firstArg = _instrNode$args2[0];

        if (isIdentifier(_firstArg)) {
          const globalOffset = moduleContext.getGlobalOffsetByIdentifier(
            // $FlowIgnore: reference?
            _firstArg.value
          );

          if (typeof globalOffset === "undefined") {
            // $FlowIgnore: reference?
            throw new Error(`global ${_firstArg.value} not found in module`);
          } // Replace the Identifer node by our new NumberLiteral node

          instrNode.args[0] = numberLiteralFromRaw(globalOffset);
        }
      }
      /**
       * Labels lookup
       */

      if (instrNode.id === "br") {
        const _instrNode$args3 = _slicedToArray(instrNode.args, 1),
          _firstArg2 = _instrNode$args3[0];

        if (isIdentifier(_firstArg2)) {
          // if the labels is not found it is going to be replaced with -1
          // which is invalid.
          let relativeBlockCount = -1; // $FlowIgnore: reference?

          instrPath.findParent(function (_ref2: any) {
            const node = _ref2.node;

            if (isBlock(node)) {
              relativeBlockCount++; // $FlowIgnore: reference?

              const name = node.label || node.name;
