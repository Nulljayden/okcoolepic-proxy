// Copyright 2012 The Obvious Corporation.

/**
 * bufs: Buffer utilities.
 */

/**
 * Module variables
 */

/**
 * Pool of buffers, where `bufPool[x].length === x`.
 * @type {Array<Buffer|undefined>}
 */
const bufPool = [];

/**
 * Maximum length of kept temporary buffers.
 * @type {number}
 */
const TEMP_BUF_MAXIMUM_LENGTH = 20;

/**
 * Minimum exactly-representable 64-bit int.
 * @type {number}
 */
const MIN_EXACT_INT64 = -0x8000000000000000;

/**
 * Maximum exactly-representable 64-bit int.
 * @type {number}
 */
const MAX_EXACT_INT64 = 0x7ffffffffffffc00;

/**
 * Maximum exactly-representable 64-bit uint.
 * @type {number}
 */
const MAX_EXACT_UINT64 = 0xfffffffffffff800;

/**
 * The int value consisting just of a 1 in bit #32 (that is, one more
 * than the maximum 32-bit unsigned value).
 * @type {number}
 */
const BIT_32 = 0x100000000;

/**
 * The int value consisting just of a 1 in bit #64 (that is, one more
 * than the maximum 64-bit unsigned value).
 * @type {number}
 */
const BIT_64 = 0x10000000000000000;

/**
 * Helper functions
 */

/**
 * Masks off all but the lowest bit set of the given number.
 * @param {number} num
 * @return {number}
 */
function lowestBit(num) {
  return num & -num;
}

/**
 * Gets whether trying to add the second number to the first is lossy
 * (inexact). The first number is meant to be an accumulated result.
 * @param {number} accum
 * @param {number} num
 * @return {boolean}
 */
function isLossyToAdd(accum, num) {
  if (num === 0) {
    return false;
  }

  const lowBit = lowestBit(num);
  const added = accum + lowBit;

  if (added === accum) {
    return true;
  }

  if (added - lowBit !== accum) {
    return true;
  }

  return false;
}

/**
 * Exported functions
 */

/**
 * Allocates a buffer of the given length, which is initialized
 * with all zeroes. This returns a buffer from the pool if it is
 * available, or a freshly-allocated buffer if not.
 * @param {number} length
 * @return {Buffer}
 */
export function alloc(length) {
  if (!Number.isSafeInteger(length) || length < 0) {
    throw new Error('Invalid length');
  }

  const result = bufPool[length];

  if (result) {
    bufPool[length] = undefined;
  } else {
    result = new Buffer(length);
  }

  result.fill(0);
  return result;
}

/**
 * Releases a buffer back to the pool.
 * @param {Buffer} buffer
 */
export function free(buffer) {
  if (!Buffer.isBuffer(buffer)) {
    throw new Error('Invalid buffer');
  }

  const length = buffer.length;

  if (length < TEMP_BUF_MAXIMUM_LENGTH) {
    bufPool[length] = buffer;
  }
}

/**
 * Resizes a buffer, returning a new buffer. Returns the argument if
 * the length wouldn't actually change. This function is only safe to
 * use if the given buffer was allocated within this module (since
 * otherwise the buffer might possibly be shared externally).
 * @param {Buffer} buffer
 * @param {number} length
 * @return {Buffer}
 */
export function resize(buffer, length) {
  if (!Buffer.isBuffer(buffer)) {
    throw new Error('Invalid buffer');
  }

  if (!Number.isSafeInteger(length) || length < 0) {
    throw new Error('Invalid length');
  }

  if (length === buffer.length) {
    return buffer;
  }

  const newBuf = alloc(length);
  buffer.copy(newBuf);
  free(buffer);
  return newBuf;
}

/**
 * Reads an arbitrary signed int from a buffer.
 * @param {Buffer} buffer
 * @return {{value: number, lossy: boolean}}
 */
export function readInt(buffer) {
  if (!Buffer.isBuffer(buffer)) {
    throw new Error('Invalid buffer');
  }

  const length = buffer.length;
  let positive = buffer[length - 1] < 0x80;
  let result = positive ? 0 : -1;
  let lossy = false;

  if (length < 7) {
    // Common case which can't possibly be lossy (because the result has
    // no more than 48 bits, and loss only happens with 54 or more).
    for (let i = length - 1; i >= 0; i--) {
      result = result * 0x100 + buffer[i];
