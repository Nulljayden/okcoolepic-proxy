"use strict";

Object.defineProperty(exports, "__esModule", { value: true });

function invertMap(obj) {
  const keyModifierFn = (k) => k;
  const result = {};
  const keys = Object.keys(obj);

  for (let i = 0, length = keys.length; i < length; i++) {
    result[keyModifierFn(obj[keys[i]])] = keys[i];
  }

  return result;
}

const illegalop = "illegal";
const magicModuleHeader = [0x00, 0x61, 0x73, 0x6d];
const moduleVersion = [0x01, 0x00, 0x00, 0x00];

function createSymbol(name, numberOfArgs = 0) {
  return { name, numberOfArgs };
}

function valtypeToName(valtype) {
  switch (valtype) {
    case 0x7f:
      return "i32";
    case 0x7e:
      return "i64";
    case 0x7d:
      return "f32";
    case 0x7c:
      return "f64";
    case 0x7b:
      return "v128";
    default:
      throw new Error(`Invalid valtype: ${valtype}`);
  }
}

function globalTypeToName(globalType) {
  switch (globalType) {
    case 0x00:
      return "const";
    case 0x01:
      return "var";
    default:
      throw new Error(`Invalid global type: ${globalType}`);
  }
}

function importTypeToName(importType) {
  switch (importType) {
    case 0x00:
      return "func";
    case 0x01:
      return "table";
    case 0x02:
      return "mem";
    case 0x03:
      return "global";
    default:
      throw new Error(`Invalid import type: ${importType}`);
  }
}

function blockTypeToName(blockType) {
  if (blockType === null) {
    return null;
  }

  return valtypeToName(blockType);
}

function typeToName(type) {
  switch (type) {
    case 0x60:
      return "func";
    case 0x40:
      return "result";
    default:
      throw new Error(`Invalid type: ${type}`);
  }
}

function exportTypeToName(exportType) {
  switch (exportType) {
    case 0x00:
      return "Func";
    case 0x01:
      return "Table";
    case 0x02:
      return "Mem";
    case 
