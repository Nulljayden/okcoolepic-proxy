"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createEmptySection = createEmptySection;

const wasmGen = require("@webassemblyjs/wasm-gen");
const helperBuffer = require("@webassemblyjs/helper-buffer");
const helperWasmBytecode = require("@webassemblyjs/helper-wasm-bytecode");
const ast = require("@webassemblyjs/ast");

function findLastSection(ast, targetSection) {
  const moduleSections = ast.body[0].metadata.sections;
  let lastSection = null;
  let lastId = 0;

  for (let i = 0, len = moduleSections.length; i < len; i++) {
    const section = moduleSections[i];

    if (section.section === "custom") {
      continue;
    }

    const sectionId = helperWasmBytecode.sections[section.section];

    if (targetSection > lastId && targetSection < sectionId) {
      return lastSection;
    }

    lastId = sectionId;
    lastSection = section;
  }

  return lastSection;
}

function createEmptySection(ast, uint8Buffer, section) {
  if (!ast || !ast.body || !ast.body[0] || !ast.body[0].metadata || !ast.body[0].metadata.sections) {
    throw new Error("Invalid AST");
  }

  if (!Buffer.isBuffer(uint8Buffer)) {
    throw new Error("Invalid uint8Buffer");
  }

  const lastSection = findLastSection(ast, section);
  let start, end;

  if (!lastSection || lastSection.section === "custom") {
    start = 8; // wasm header size
    end = start;
  } else {
    start = lastSection.startOffset + lastSection.size.value + 1;
    end = start;
  }

  start += 1; // section id

  const sizeStartLoc = {
    line: -1,
    column: start
  };
  const sizeEndLoc = {
    line: -1,
    column: start + 1
  };
  const size = ast.withLoc(ast.numberLiteralFromRaw(1), sizeEndLoc, sizeStartLoc);
  const vectorOfSizeStartLoc = {
    line: -1,
    column: sizeEndLoc.column
  };
  const vectorOfSizeEndLoc = {
    line: -1,
    column: sizeEndLoc.column + 1
  };
  const vectorOfSize = ast.withLoc(ast.numberLiteralFromRaw(0), vectorOfSizeEndLoc, vectorOfSizeStartLoc);
  const sectionMetadata = ast.sectionMetadata(section, start, size, vectorOfSize);
  const sectionBytes = wasmGen.encodeNode(sectionMetadata);
  uint8Buffer = helperBuffer.overrideBytesInBuffer(uint8Buffer, start - 1, end, sectionBytes); // Add section into the AST for later lookups

  if (typeof ast.body[0].metadata.sections === "object") {
    ast.body[0].metadata.sections.push(sectionMetadata);
    ast.sortSectionMetadata(ast.body[0]);
  }
  /**
   * Update AST
   */

  let deltaBytes = sectionBytes.length;
  let encounteredSection = false;
  ast.traverse(ast, {
    SectionMetadata: function SectionMetadata(path) {
      if (path.node.section === section) {
        encounteredSection = true;
        return;
      }

      if (encounteredSection === true) {
        ast.shiftSection(ast, path.node, deltaBytes);
      }
    }
  });
  return {
    uint8Buffer: uint8Buffer,
    sectionMetadata: sectionMetadata
  };
}
