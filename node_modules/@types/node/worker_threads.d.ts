/**
 * The `worker_threads` module enables the use of threads that execute JavaScript
 * in parallel. To access it:
 *
 * ```js
 * const worker = require('worker_threads');
 * ```
 *
 * Workers (threads) are useful for performing CPU-intensive JavaScript operations.
 * They do not help much with I/O-intensive work. The Node.js built-in
 * asynchronous I/O operations are more efficient than Workers can be.
 *
 * Unlike `child_process` or `cluster`, `worker_threads` can share memory. They do
 * so by transferring `ArrayBuffer` instances or sharing `SharedArrayBuffer`instances.
 */

import {
  Worker,
  isMainThread,
  parentPort,
  workerData,
  MessageChannel,
  WorkerPerformance,
  TransferListItem,
  MessagePort,
  WorkerOptions,
  ResourceLimits,
} from 'worker_threads';

if (isMainThread) {
  module.exports = function parseJSAsync(script: string) {
    return new Promise<any>((resolve, reject) => {
      const worker = new Worker(__filename, {
        workerData: script,
      });
      worker.on('message', (message: any) => {
        resolve(message);
      });
      worker.on('error', reject);
      worker.on('exit', (code: number) => {
        if (code !== 0) {
          reject(new Error(`Worker stopped with exit code ${code}`));
        }
      });
    });
  };
} else {
  const { parse } = require('some-js-parsing-library');
  const script = workerData;
  parentPort?.postMessage(parse(script));
}

/**
 * When implementing a worker pool, use the `AsyncResource` API to inform
 * diagnostic tools (e.g. to provide asynchronous stack traces) about the
 * correlation between tasks and their outcomes. See `"Using AsyncResource for a Worker thread pool"` in the `async_hooks` documentation for an example implementation.
 *
 * Worker threads inherit non-process-specific options by default. Refer to `Worker constructor options` to know how to customize worker thread options,
 * specifically `argv` and `execArgv` options.
 */
