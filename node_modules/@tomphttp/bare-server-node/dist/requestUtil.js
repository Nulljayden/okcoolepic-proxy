/**
 * Request utility module for making HTTP/HTTPS requests.
 */

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.upgradeFetch = exports.fetch = void 0;
const BareServer_js_1 = require("./BareServer.js");
const http = require("node:http");
const https = require("node:https");

const httpAgent = new http.Agent({
    keepAlive: true,
    timeout: 12e3,
});

const httpsAgent = new https.Agent({
    keepAlive: true,
    timeout: 12e3,
});

/**
 * Converts a given error to a `BareError` instance if necessary.
 * @param error - The error object to convert.
 * @returns The converted error object.
 */
function outgoingError(error: Error): Error {
    if (error instanceof Error) {
        switch (error.code) {
            case 'ENOTFOUND':
                return new BareServer_js1.BareError(500, {
                    code: 'HOST_NOT_FOUND',
                    id: 'request',
                    message: 'The specified host could not be resolved.',
                });
            case 'ECONNREFUSED':
                return new BareServer_js1.BareError(500, {
                    code: 'CONNECTION_REFUSED',
                    id: 'response',
                    message: 'The remote rejected the request.',
                });
            case 'ECONNRESET':
                return new BareServer_js1.BareError(500, {
                    code: 'CONNECTION_RESET',
                    id: 'response',
                    message: 'The request was forcibly closed.',
                });
            case 'ETIMEOUT':
                return new BareServer_js1.BareError(500, {
                    code: 'CONNECTION_TIMEOUT',
                    id: 'response',
                    message: 'The response timed out.',
                });
        }
    }
    return error;
}

/**
 * Makes an HTTP/HTTPS request to a given URL.
 * @param config - The configuration object for the request.
 * @param request - The request object to send.
 * @param signal - The AbortSignal object to use for canceling the request.
 * @param requestHeaders - The headers object to use for the request.
 * @param url - The URL object to request.
 * @returns A Promise that resolves to the response object.
 */
async function fetch(config: any, request: any, signal: AbortSignal, requestHeaders: any, url: URL): Promise<http.IncomingMessage> {
    const options: http.RequestOptions = {
        host: url.host,
        port: url.port,
        path: url.path,
        method: request.method,
        headers: requestHeaders,
        setHost: false,
        localAddress: config.localAddress,
        signal,
    };
    let outgoing: http.ClientRequest;
    if (url.protocol === 'https:') {
        outgoing = https.request(options, httpsAgent);
    } else if (url.protocol === 'http:') {
        outgoing = http.request(options, httpAgent);
    } else {
        throw new RangeError(`Unsupported protocol: '${url.protocol}'`);
    }
    request.body.pipe(outgoing);
    return new Promise((resolve, reject) => {
        outgoing.on('response', (response: http.IncomingMessage) => {
            resolve(response);
        });
        outgoing.on('upgrade', (req: http.ClientRequest, socket: net.Socket) => {
            reject(new Error('Remote did not send a response'));
            socket.destroy();
        });
        outgoing.on('error', (error: Error) => {
            reject(outgoingError(error));
        });
    });
}
exports.fetch = fetch;

/**
 * Upgrades an HTTP/HTTPS request to a WebSocket connection.
 * @param serverConfig - The configuration object for the server.
 * @param request - The request object to upgrade.
 * @param signal - The AbortSignal object to use for canceling the request.
 * @param requestHeaders - The headers object to use for the request.
 * @param remote - The URL object to upgrade to.
 * @returns A Promise that resolves to the upgraded WebSocket connection.
 */
async function upgradeFetch(serverConfig: any, request: any, signal: AbortSignal, requestHeaders: any, remote: URL): Promise<[http.IncomingMessage, net.Socket, Buffer]> {
    const options: http.RequestOptions = {
        host: remote.host,
        port: remote.port,
        path: remote.path,
        headers: requestHeaders,
        method: request.method,
        setHost: false,
        localAddress: serverConfig.localAddress,
        signal,
    };
    let outgoing: http.ClientRequest;
    if (remote.protocol === 'wss:') {
        outgoing = https.request(options, httpsAgent);
    } else if (remote.protocol === 'ws:') {
        outgoing = http.request(options, httpAgent);
    } else {
        throw new RangeError(`Unsupported protocol: '${remote.protocol}'`);
    }
    outgoing.end();
    return new Promise((resolve, reject) => {
        outgoing.on('response', (res: http.IncomingMessage) => {
            reject(new Error('Remote did not upgrade the WebSocket'));
            res.destroy();
        });
        outgoing.on('upgrade', (res: http.IncomingMessage, socket: net.Socket, head: Buffer) => {
            resolve([res, socket, head]);
