import { AbortController } from 'node-abort-controller';
import AbstractMessage, { AbstractMessageResponse } from './AbstractMessage.js';
import BareError from './BareError.js';
import BareServer from './BareServer.js';
import headerUtil from './headerUtil.js';
import requestUtil from './requestUtil.js';
import splitHeaderUtil from './splitHeaderUtil.js';
import HeadersPolyfill from 'headers-polyfill';
import crypto from 'node:crypto';
import util from 'node:util';
import validProtocols from './validProtocols.js';
import { Request } from 'node-mocks-http';

const forbiddenForwardHeaders = [
  'connection',
  'transfer-encoding',
  'host',
  'connection', // duplicate removed
  'origin',
  'referer',
];

const forbiddenPassHeaders = [
  'vary',
  'connection',
  'transfer-encoding',
  'access-control-allow-headers',
  'access-control-allow-methods',
  'access-control-expose-headers',
  'access-control-max-age',
  'access-control-request-headers',
  'access-control-request-method',
];

const defaultForwardHeaders = [
  'accept-encoding',
  'accept-language',
  'sec-websocket-extensions',
  'sec-websocket-key',
  'sec-websocket-version',
];

const defaultPassHeaders = [
  'content-encoding',
  'content-length',
  'last-modified',
];

const defaultCacheForwardHeaders = [
  'if-modified-since',
  'if-none-match',
  'cache-control',
];

const defaultCachePassHeaders = ['cache-control', 'etag'];

const cacheNotModified = 304;

const randomBytesAsync = util.promisify(crypto.randomBytes);

function loadForwardedHeaders(forward, target, request) {
  for (const header of forward) {
    if (request.headers.has(header)) {
      target[header] = request.headers.get(header);
    }
  }
}

const splitHeaderValue = /,\s*/g;

function readHeaders(request) {
  const remote = {
    host: undefined,
    port: undefined,
    protocol: undefined,
    path: undefined,
  };

  const sendHeaders = {};
  const passHeaders = [...defaultPassHeaders];
  const passStatus = [];
  const forwardHeaders = [...defaultForwardHeaders];

  const headers = splitHeaderUtil.joinHeaders(request.headers);

  for (const remoteProp of ['host', 'port', 'protocol', 'path']) {
    const header = `x-bare-${remoteProp}`;
    if (headers.has(header)) {
      const value = headers.get(header);
      switch (remoteProp) {
        case 'port':
          if (isNaN(parseInt(value))) {
            throw new BareError(400, {
              code: 'INVALID_BARE_HEADER',
              id: `request.headers.${header}`,
              message: `Header was not a valid integer.`,
            });
          }
          break;
        case 'protocol':
          if (!validProtocols.includes(value)) {
            throw new BareError(400, {
              code: 'INVALID_BARE_HEADER',
              id: `request.headers.${header}`,
              message: `Header was invalid`,
            });
          }
          break;
      }
      remote[remoteProp] = value;
    } else {
      throw new BareError(400, {
        code: 'MISSING_BARE_HEADER',
        id: `request.headers.${header}`,
        message: `Header was not specified.`,
      });
    }
  }

  // ... rest of the function
}

async function tunnelRequest(serverConfig, request, res) {
  // ... rest of the function
}

async function getMeta(serverConfig, request) {
  // ... rest of the function
}

async function newMeta(serverConfig, request) {
  // ... rest of the function
}

async function tunnelSocket(serverConfig, request, socket) {
  // ... rest of the function
}

function registerV2(server) {
  // ... rest of the function
}

export default registerV2;
