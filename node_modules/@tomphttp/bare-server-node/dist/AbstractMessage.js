/**
 * Abstraction for the data read from IncomingMessage
 */
class Request {
  /**
   * @param {NodeJS.ReadableStream} body
   * @param {import('http').IncomingHttpHeaders} init
   */
  constructor(body, init) {
    this.body = body;
    this.method = init.method;
    this.headers = new headers_polyfill_1.Headers(init.headers);
    this.url = new URL(`http://${this.headers.get('host')}${init.url}`);
  }

  /**
   * @type {URLSearchParams}
   */
  get query() {
    return this.url.searchParams;
  }
}
exports.Request = Request;

/**
 * Abstraction for the data to be written to OutgoingMessage
 */
class Response {
  /**
   * @param {Buffer|NodeJS.ReadableStream} body
   * @param {object} [init]
   */
  constructor(body, init = {}) {
    if (body) {
      this.body = body instanceof node_stream_1.Stream ? body : Buffer.from(body);
    }

    if (typeof init.status === 'number') {
      this.status = init.status;
    } else {
      this.status = 200;
    }

    if (typeof init.statusText === 'string') {
      this.statusText = init.statusText;
    } else {
      this.statusText = 'OK';
    }

    if (init.headers) {
      this.headers = new headers_polyfill_1.Headers(init.headers);
    } else {
      this.headers = new headers_polyfill_1.Headers();
    }
  }
}
exports.Response = Response;

/**
 * Writes the response to the outgoing message
 * @param {Response} response
 * @param {import('http').ServerResponse} res
 * @returns {boolean}
 */
function writeResponse(response, res) {
  for (const [header, value] of response.headers) {
    res.setHeader(header, value);
  }

  res.writeHead(response.status, response.statusText || 'OK');

  if (response.body instanceof node_stream_1.Stream) {
    const { body } = response;
    res.on('close', () => body.destroy());

    try {
      body.pipe(res);
    } catch (err) {
      // Handle error here
    }
  } else if (response.body instanceof Buffer) {
    res.end(
