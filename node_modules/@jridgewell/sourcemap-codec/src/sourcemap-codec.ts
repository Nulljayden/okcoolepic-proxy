export type SourceMapSegment =
  | [number]
  | [number, number, number, number]
  | [number, number, number, number, number];

export type SourceMapLine = SourceMapSegment[];
export type SourceMapMappings = SourceMapLine[];

const comma = ','.charCodeAt(0);
const semicolon = ';'.charCodeAt(0);
const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
const intToChar = new Uint8Array(64); // 64 possible chars.
const charToInt = new Uint8Array(128); // z is 122 in ASCII

for (let i = 0; i < chars.length; i++) {
  const c = chars.charCodeAt(i);
  intToChar[i] = c;
  charToInt[c] = i;
}

// Provide a fallback for older environments.
const td =
  typeof TextDecoder !== 'undefined'
    ? /* #__PURE__ */ new TextDecoder()
    : typeof Buffer !== 'undefined'
    ? {
        decode(buf: Uint8Array) {
          const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
          return out.toString();
        },
      }
    : {
        decode(buf: Uint8Array) {
          let out = '';
          for (let i = 0; i < buf.length; i++) {
            out += String.fromCharCode(buf[i]);
          }
          return out;
        },
      };

/**
 * Decodes a source map mappings string into an array of arrays of segments.
 * @param mappings The source map mappings string to decode.
 * @returns The decoded source map mappings.
 */
export function decode(mappings: string): SourceMapMappings {
  const state: [number, number, number, number, number] = new Int32Array(5) as any;
  const decoded: SourceMapMappings = [];

  let index = 0;
  do {
    const semi = indexOf(mappings, index);
    const line: SourceMapLine = [];
    let sorted = true;
    let lastCol = 0;
    state[0] = 0;

    for (let i = index; i < semi; i++) {
      let seg: SourceMapSegment;

      i = decodeInteger(mappings, i, state, 0); // genColumn
      const col = state[0];
      if (col < lastCol) sorted = false;
      lastCol = col;

      if (hasMoreVlq(mappings, i, semi)) {
        i = decodeInteger(mappings, i, state, 1); // sourcesIndex
        i = decodeInteger(mappings, i, state, 2); // sourceLine
        i = decodeInteger(mappings, i, state, 3); // sourceColumn

        if (hasMoreVlq(mappings, i, semi)) {
          i = decodeInteger(mappings, i, state, 4); // namesIndex
          seg = [col, state[1], state[2], state[3], state[4]];
        } else {
          seg = [col, state[1], state[2], state[3]];
        }
      } else {
        seg = [col];
      }

      line.push(seg);
    }

    if (!sorted) sort(line);
    decoded.push(line);
    index = semi + 1;
  } while (index <= mappings.length);

  return decoded;
}

/**
 * Returns the index of the semicolon character in the given mappings string
 * starting from the given index, or the length of the mappings string if
 * the semicolon character is not found.
 * @param mappings The source map mappings string.
 * @param index The index to start searching from.
 * @returns The index of the semicolon character or the length of the
 * mappings string.
 */
function indexOf(mappings: string, index: number): number {
  const idx = mappings.indexOf(';', index);
  return idx === -1 ? mappings.length : idx;
}

/**
 * Decodes a VLQ-encoded integer from the given mappings string starting from
 * the given position, and updates the given state array accordingly.
 * @param mappings The source map mappings string.
 * @param pos The position to start decoding from.
 * @param state The state array to update.
 * @param j The index of the state array to update.
 * @returns The updated position after decoding the integer.
 */
function decodeInteger(
  mappings: string,
  pos: number,
  state: SourceMapSegment,
  j: number,
): number {
  let value = 0;
  let shift = 0;
  let integer = 0;

  do {
    const c = mappings.charCodeAt(pos++);
    integer = charToInt[c];
    value |= (integer & 31) << shift;
    shift += 5;
  } while (integer & 32);

  const shouldNegate = value & 1;
  value >>>= 1;

  if (shouldNegate) {
    value = -0x80000000 | -value;
  }

  state[j] += value;
  return pos;
}

/**
 * Checks if there are more VLQ-encoded integers in the given mappings string
 * starting from the given position and up to the given
