(function (global: any, factory: (exports: any) => void) {
    if (typeof exports === 'object' && typeof module !== 'undefined') {
        factory(exports);
    } else if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
    } else {
        global.sourcemapCodec = factory(global.sourcemapCodec || {});
    }
})(this, (function (exports) {
    'use strict';

    const comma = ','.charCodeAt(0);
    const semicolon = ';'.charCodeAt(0);
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    const intToChar = new Uint8Array(64); // 64 possible chars.
    const charToInt = new Uint8Array(128); // z is 122 in ASCII
    for (let i = 0; i < chars.length; i++) {
        const c = chars.charCodeAt(i);
        intToChar[i] = c;
        charToInt[c] = i;
    }

    const decode = (mappings: string): any[][] => {
        const state = new Int32Array(5);
        const decoded: any[][] = [];
        let index = 0;

        while (index < mappings.length) {
            const semi = mappings.indexOf(';', index);
            const line: any[] = [];
            let sorted = true;
            let lastCol = 0;
            state[0] = 0;

            for (let i = index; i < semi; i++) {
                let seg;
                i = decodeInteger(mappings, i, state, 0); // genColumn
                const col = state[0];
                if (col < lastCol)
                    sorted = false;
                lastCol = col;

                if (hasMoreVlq(mappings, i, semi)) {
                    i = decodeInteger(mappings, i, state, 1); // sourcesIndex
                    i = decodeInteger(mappings, i, state, 2); // sourceLine
                    i = decodeInteger(mappings, i, state, 3); // sourceColumn

                    if (hasMoreVlq(mappings, i, semi)) {
                        i = decodeInteger(mappings, i, state, 4); // namesIndex
                        seg = [col, state[1], state[2], state[3], state[4]];
                    }
                    else {
                        seg = [col, state[1], state[2], state[3]];
                    }
                }
                else {
                    seg = [col];
                }

                line.push(seg);
            }

            if (!sorted)
                line.sort(sortComparator);

            decoded.push(line);
            index = semi + 1;
        }

        return decoded;
    };

    const indexOf = (mappings: string, index: number) => {
        const idx = mappings.indexOf(';', index);
        return idx === -1 ? mappings.length : idx;
    };

    const decodeInteger = (mappings: string, pos: number, state: Int32Array, j: number) => {
        let value = 0;
        let shift = 0;
        let integer = 0;

        do {
            const c = mappings.charCodeAt(pos++);
            integer = charToInt[c];
            value |= (integer & 31) << shift;
            shift += 5;
        } while (integer & 32);

        const shouldNegate = value & 1;
        value >>>= 1;

        if (shouldNegate) {
            value = -0x80000000 | -value;
        }

        state[j] += value;
        return pos;
    };

    const hasMoreVlq = (mappings: string, i: number, length: number) => {
        if (i >= length)
            return false;
        return mappings.charCodeAt(i) !== comma;
    };

    const sort = (line: any[]) => {
        line.sort(sortComparator);
    };

    const sortComparator = (a: any[], b: any[]) => {
        return a[0] - b[0];
    };

    const encode = (decoded: any[][]) => {
        const state = new Int32Array(5);
        const bufLength = 1024 * 16;
        const subLength = bufLength - 36;
        const buf = new Uint8Array(bufLength);
        const sub = buf.subarray(0, subLength);
        let pos = 0;
        let out = '';

        for (let i = 0; i < decoded.length; i++) {
            const line = decoded[i];

            if (i > 0) {
                if (pos === bufLength) {
                    out += String.fromCharCode.apply(null, buf.subarray(0, pos));
                    pos = 0;
                }
                buf[pos++] = semicolon;
            }

            if (line.length === 0)
                continue;

            state[0] = 0;

            for (let j = 0; j < line.length; j++) {
                const segment = line[j];

                if (pos > subLength)
