import type { SourceMapSegment, ReverseSegment } from './sourcemap-segment';

export interface MemoState {
  lastKey: number;
  lastNeedle: number;
  lastIndex: number;
}

export let found = false;

/**
 * A binary search implementation that returns the index if a match is found.
 * If no match is found, then the left-index (the index associated with the item that comes just
 * before the desired index) is returned. To maintain proper sort order, a splice would happen at
 * the next index.
 */
export function binarySearch(
  haystack: SourceMapSegment[] | ReverseSegment[],
  needle: number,
  low: number,
  high: number
): number {
  // Implementation here
}

export function upperBound(
  haystack: SourceMapSegment[] | ReverseSegment[],
  needle: number,
  index: number
): number {
  // Implementation here
}

export function lowerBound(
  haystack: SourceMapSegment[] | ReverseSegment[],
  needle: number,
  index: number
): number {
  // Implementation here
}

export function memoizedState(): MemoState {
  return {
    lastKey: -1,
    lastNeedle: -1,
    lastIndex: -1
  };
}

/**
 * This overly complicated beast is just to record the last tested line/column and the resulting
 * index, allowing us to skip a few tests if mappings are monotonically increasing.
 */
export function memoizedBinarySearch(
  haystack: SourceMapSegment[] | ReverseSegment[],
  needle: number,
  state: MemoState,
  key: number
): number {
  // Implementation here
}
