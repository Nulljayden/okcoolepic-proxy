'use strict';

module.exports = function generateProperties(keywordContext, keyword, ruleType) {
  const {
    level,
    dataLevel,
    schema,
    schemaPath,
    errSchemaPath,
    breakOnError,
    opts: { allErrors, jsonPointers, useDefaults, ownProperties, removeAdditional, strictKeywords, createErrors, verbose, messages },
  } = keywordContext;
  const currentBaseId = keywordContext.baseId;
  const lvl = `level_${level}`;
  const data = `data${dataLevel}`;
  const errs = `errs__${lvl}`;
  const it = keywordContext.util.copy(keywordContext);
  it.level++;
  const nextValid = `valid${it.level}`;
  const key = `key${lvl}`;
  const idx = `idx${lvl}`;
  const dataNxt = dataLevel + 1;
  const nextData = `data${dataNxt}`;
  const dataProperties = `dataProperties${lvl}`;

  const schemaKeys = Object.keys(schema || {}).filter(p => p !== '__proto__');
  const patternProperties = schema.patternProperties || {};
  const pPropertyKeys = Object.keys(patternProperties).filter(p => p !== '__proto__');
  const additionalProperties = schema.additionalProperties;
  const someProperties = schemaKeys.length || pPropertyKeys.length;
  const noAdditional = additionalProperties === false;
  const additionalIsSchema = typeof additionalProperties === 'object' && Object.keys(additionalProperties).length;
  const removeAdditionalCheck = removeAdditional !== false;
  const ownPropertiesCheck = ownProperties !== false;
  const required = schema.required;
  const requiredHash = required ? keywordContext.util.toHash(required) : undefined;

  let code = '';

  if (createErrors !== false) {
    code += `var ${errs} = errors;`;
  }
  if (ownPropertiesCheck) {
    code += `var ${dataProperties} = undefined;`;
  }

  if (removeAdditionalCheck) {
    if (ownPropertiesCheck) {
      code += `const dataProperties = ${dataProperties} || Object.keys(${data}); for (let ${idx} = 0; ${idx} < dataProperties.length; ${idx}++) { const ${key} = dataProperties[${idx}]; `;
    } else {
      code += `for (const ${key} in ${data}) { `;
    }

    if (someProperties) {
      code += `const isAdditional${lvl} = !(false `;
      if (schemaKeys.length) {
        code += `|| validate.schema${schemaPath}.hasOwnProperty('${key}') `;
      }
      if (pPropertyKeys.length) {
        const pProperty = pPropertyKeys[0];
        code += `|| new RegExp('${pProperty}').test('${key}') `;
      }
      code += `); if (isAdditional${lvl}) { `;
    }

    if (removeAdditional === 'all') {
      code += `delete ${data}[${key}]; `;
    } else {
      const additionalProperty = `'${key}'`;
      if (it.opts._errorDataPathProperty) {
        keywordContext.errorPath = keywordContext.util.getPathExpr(keywordContext.errorPath, key, jsonPointers);
      }

      if (noAdditional) {
        if (removeAdditional) {
          code += `delete ${data}[${key}]; `;
        } else {
          code += ` ${nextValid} = false; `;

          const currErrSchemaPath = errSchemaPath;
          errSchemaPath = `${errSchemaPath}/additionalProperties`;
          const $$outStack = $$outStack || [];
          $$outStack.push(code);
          code = '';

          code += `{ keyword: 'additionalProperties' , dataPath: (dataPath || '') + ${keywordContext.errorPath} , schemaPath: '${errSchemaPath}' , params: { additionalProperty: ${additionalProperty} } `;
          if (messages !== false) {
            code += `, message: 'is an invalid additional property' `;
          }
          if (verbose) {
            code += `, schema: false , parentSchema: validate.schema${keywordContext.schemaPath} , data: ${data} `;
          }
          code += ` } `;

          const __err = code;
          code = $$outStack.pop();
          if (!keywordContext.compositeRule && breakOnError) {
            if (keywordContext.async) {
              code += `throw new ValidationError([${__err}]); `;
            } else {
              code += `validate.errors = [${__err}]; return false; `;
            }
          } else {
            code += `var err = ${__err}; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; `;
          }
          errSchemaPath = currErrSchemaPath;
          if (breakOnError) {
            code += `break; `;
          }
        }
      } else if (additionalIsSchema) {
        if (removeAdditional === 'failing') {
          code += `const errs = ${errs}; `;
          keywordContext.compositeRule = keywordContext.compositeRule || it.compositeRule;
          keywordContext.schema = additionalProperties;
          keywordContext.schemaPath = `${schemaPath}.additionalProperties`;
          keywordContext.errSchemaPath = `${errSchemaPath}/additionalProperties`;
          keywordContext.errorPath = keywordContext.opts._errorDataPathProperty ? keywordContext.errorPath : keywordContext.util.getPath(keywordContext.errorPath, key, jsonPointers);
          const passData = `${data}[${key}]`;
          keywordContext.dataPathArr[dataNxt] = key;
          code += keywordContext.validate(keywordContext);
          keywordContext.baseId = currentBaseId;
          code += `if (!${nextValid}) { errors = errs;
