'use strict';

module.exports = function generateCustom(it, keyword, ruleType) {
  const level = it.level;
  const dataLevel = it.dataLevel;
  const schema = it.schema[keyword];
  const schemaPath = it.schemaPath + it.util.getProperty(keyword);
  const errSchemaPath = it.errSchemaPath + '/' + keyword;
  const breakOnError = !it.opts.allErrors;
  let errorKeyword;
  const data = 'data' + (dataLevel || '');
  const valid = 'valid' + level;
  const errs = 'errs__' + level;
  const isData = it.opts.$data && schema && schema.$data;
  let schemaValue;

  if (isData) {
    schemaValue = this.util.getData(schema.$data, dataLevel, it.dataPathArr);
  } else {
    schemaValue = schema;
  }

  const rule = this;
  const ruleDefinition = 'definition' + level;
  const rDef = rule.definition;
  let closingBraces = '';
  let compile, inline, macro, ruleValidate, validateCode;

  if (isData && rDef.$data) {
    validateCode = 'keywordValidate' + level;
    const validateSchema = rDef.validateSchema;
    validateCode = rDef.validate;
    closingBraces += '}';
  } else {
    ruleValidate = it.useCustomRule(rule, schema, it.schema, it);
    if (!ruleValidate) return;
    schemaValue = 'validate.schema' + schemaPath;
    validateCode = ruleValidate.code;
    compile = rDef.compile;
    inline = rDef.inline;
    macro = rDef.macro;
  }

  const ruleErrs = validateCode + '.errors';
  let i = 'i' + level;
  let ruleErr = 'ruleErr' + level;
  const asyncKeyword = rDef.async;

  let code = `
    var ${errs} = errors;
    var ${valid};
  `;

  if (isData && rDef.$data) {
    code += `
      if (${schemaValue} === undefined) {
        ${valid} = true;
      } else {
        ${valid} = ${definition}.validateSchema(${schemaValue});
        if (${valid}) {
    `;
  }

  if (inline) {
    if (rDef.statements) {
      code += `  ${ruleValidate.validate};`;
    } else {
      code += `  ${valid} = ${ruleValidate.validate};`;
    }
  } else if (macro) {
    // Macro implementation
  } else {
    // Non-macro, non-inline implementation
  }

  if (rDef.modifying) {
    code += `
      if (${parentData}) ${data} = ${parentData}[${parentDataProperty}];
    `;
  }

  code += `${closingBraces}

    if (${rDef.valid}) {
      if (${breakOnError}) {
        if (true) {
    `;

  const errorObj = `
    {
      keyword: '${errorKeyword || 'custom'}',
      dataPath: (dataPath || '') + ${it.errorPath},
      schemaPath: ${it.util.toQuotedString(errSchemaPath)},
      params: { keyword: '${rule.keyword}' }
    }
  `;

  code += `
      if (${it.opts.messages} !== false) {
        errorObj.message = 'should pass "${rule.keyword}" keyword validation';
      }
      if (${it.opts.verbose}) {
        errorObj.schema = ${schemaValue};
        errorObj.data = ${data};
      }
    } else {
      const err = ${errorObj};

      if (!it.compositeRule && ${breakOnError}) {
        if (${it.async}) {
          throw new ValidationError([err]);
        } else {
          validate.errors = [err];
          return false;
        }
      } else {
        const vErrors = ${it.createErrors !== false ? 'vErrors || []' : '[]'};
        vErrors.push(err);
        errors++;
      }
    }
  `;

  return code;
}
